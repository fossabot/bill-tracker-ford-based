## Goal: One consistent set of commands that both GitHub Actions and Tekton run.



Add Gradle tasks and conventions:

* ./gradlew test

* ./gradlew check (linting later if you add it)

* ./gradlew sonar (but only in CI with env vars)

Add a minimal GitHub Actions workflow that runs:

* test

* sonar

* fossa analyze

Before we do 0.3, do this tiny alignment check:

Quick check

1. Confirm you have this file committed:

* backend/src/main/resources/application.properties

2. Confirm application-local.properties is ignored by git.


    * git status

## 0.3.1 Add SonarQube Gradle plugin + config (SonarCloud)

Open backend/build.gradle and add the SonarQube plugin and config.

A) Plugin Exists or Added

in the plugins block, add:
    * id 'org.sonarqube' version '6.0.1.5171'


B) Configure SonarCloud using environment variables

add near bottoom of backend/build.gradle:

```gradle
sonar {
    properties {
           property "sonar.host.url", "https://sonarcloud.io"
    property "sonar.projectKey", System.getenv("SONAR_PROJECT_KEY") ?: ""
    property "sonar.organization", System.getenv("SONAR_ORG") ?: ""
    property "sonar.token", System.getenv("SONAR_TOKEN") ?: ""
    }
}
```

## 0.3.2 Add GitHub Actions workflow for CI

## 0.3.2 GitHub Actions workflow (what’s going on, why we do it)

### What a GitHub Actions workflow actually is

A workflow is a recipe that GitHub runs for you on every PR and on pushes to `main`.

- It runs on a clean machine (runner).
- It checks out your code.
- It runs your build commands.
- It fails the PR if the checks fail.

This turns **“it works on my laptop”** into **“it works on the repo.”**

GitHub’s own docs describe Actions as workflow automation for CI/CD.  
*(GitHub Docs)*

---

### The heuristic behind the workflow

Here’s the mental model you want to internalize so you can build these yourself later:

**Heuristic: _“One pipeline, one truth.”_**

- A developer should be able to run the same commands locally that CI runs.
- CI should mostly just “run those commands in a clean environment.”

So we structure workflow steps to match your real build gates:

1. **Build + tests**  
   Proves code compiles, tests pass

2. **Static analysis (SonarCloud)**  
   Catches code smells, bugs, coverage issues  
   *(depending on your rules)*  
   *(Sonar Documentation)*

3. **SCA (FOSSA)**  
   Checks third-party dependencies for license/security risk  
   *(FOSSA)*

That’s the whole philosophy:

- **Correctness** (tests)
- **Code quality** (Sonar)
- **Supply chain safety** (FOSSA)

---

### Why we do it in Slice 0

Because later slices (auth, bills, etc.) get complex fast. If you wait to wire CI until later, you end up **“refactoring while blind.”**

Slice 0 is about making sure every next slice is built with guardrails.


create file: .github/workflows/backend-ci.yml

```yaml 
name: backend-ci

on:
  pull_request:
    paths:
      - "backend/**"
  push:
    branches: [ main ]
    paths:
      - "backend/**"

jobs:
  build-test-scan:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: backend

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "21"

      - uses: gradle/actions/setup-gradle@v4

      - name: Test
        run: ./gradlew test

      # SonarCloud analysis
      - name: SonarCloud Scan
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
          SONAR_ORG: ${{ secrets.SONAR_ORG }}
        run: ./gradlew sonar

      # FOSSA analysis
      - name: Install FOSSA CLI
        run: |
          curl -H 'Cache-Control: no-cache' https://raw.githubusercontent.com/fossas/fossa-cli/master/install.sh | bash

      - name: FOSSA Analyze
        env:
          FOSSA_API_KEY: ${{ secrets.FOSSA_API_KEY }}
        run: fossa analyze

```

