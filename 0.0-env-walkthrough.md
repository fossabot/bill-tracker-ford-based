Step 0.1 Create the repo and Spring Boot backend skeleton (Gradle)
0.1.1 Create the folder structure

From your workspace directory:

```
mkdir bill-tracker-ford-based
cd bill-tracker-ford-based
mkdir backend frontend

```


Checkpoint

```
ls

```

Expected output includes:

backend

frontend

0.1.2 Generate Spring Boot project into backend/

Use Spring Initializr (web UI or CLI). Choose:

* Project: Gradle (Groovy DSL)

* Language: Java

* Spring Boot: latest stable in your org (if unsure, pick latest stable)

* Group: com.altruisticsoftwaredevelopment

* Artifact: bill-tracker-ford-based-backend

* Java: 21

* Packaging: Jar

* Dependencies:

  * Spring Web

  * Spring Data JPA

  * Validation

  * Liquibase Migration

  * PostgreSQL Driver

  * (Optional now, but I like it early) Spring Boot Actuator`

Download the zip and extract it into the backend/ folder so you end up with:

bill-tracker-ford-based/backend/build.gradle

bill-tracker-ford-based/backend/src/main/java/...


```
ls backend

```

Expected:

* build.gradle

* settings.gradle

* gradlew

* gradlew.bat

* src/

0.1.3 Make sure the backend builds and tests pass (baseline)

Run:
```
cd backend
./gradlew clean test
```

Checkpoint

Build should succeed.

You should see something like BUILD SUCCESSFUL.

If this fails, don’t continue. The whole point is “foundation first.”

Errors along the way

```

Starting a Gradle Daemon (subsequent builds will be faster)

> Task :test FAILED

BillTrackerFordBasedBackendApplicationTests > contextLoads() FAILED
    java.lang.IllegalStateException at DefaultCacheAwareContextLoaderDelegate.java:195
        Caused by: org.springframework.beans.factory.BeanCreationException at AbstractBeanFactory.java:322
            Caused by: org.springframework.beans.factory.BeanCreationException at ConstructorResolver.java:657
                Caused by: org.springframework.beans.BeanInstantiationException at SimpleInstantiationStrategy.java:183
                    Caused by: org.springframework.beans.factory.BeanCreationException at ConstructorResolver.java:657
                        Caused by: org.springframework.beans.BeanInstantiationException at SimpleInstantiationStrategy.java:183
                            Caused by: org.springframework.boot.jdbc.autoconfigure.DataSourceProperties$DataSourceBeanCreationException at DataSourceProperties.java:179

1 test completed, 1 failed
```

This is not a Gradle problem. Gradle is just reporting that your Spring Boot test contextLoads() failed while starting the application context, and the deepest cause is:

DataSourceProperties$DataSourceBeanCreationException

That almost always means:

Spring Boot tried to auto-configure a DataSource

It could not build it because DB connection settings are missing/invalid (URL, driver, username/password), or a related DB bean (Liquibase/JPA) forced it to initialize and failed.

What’s happening in plain English

contextLoads() is the “can my app start?” test. Spring Boot starts up your whole app context. During startup it tries to create the DataSource bean. That creation failed, so the whole context failed, so the test failed.

Think of it like: the test tried to boot the car, but the fuel line (DataSource config) isn’t hooked up.

The most common root causes
1) No DB configuration available for tests

If you don’t have spring.datasource.url (and usually driver), Spring can’t connect.

You may have DB config in application.yml, but your tests might be running with a different profile or missing env vars.

2) You rely on environment variables that are not set during tests

Example: spring.datasource.password: ${DB_PASSWORD} but DB_PASSWORD is not set when running ./gradlew test.

3) You expect Docker/Testcontainers DB, but it’s not running

If tests assume Postgres/MySQL container and it didn’t start, you’ll see datasource creation fail (often with connection refused in the full stack trace).

4) Liquibase (or Flyway) runs on startup and fails

Even if the DataSource is technically creatable, Liquibase can fail migrations and bubble up as a DataSource-related failure.

How to confirm the exact reason in 10 seconds

Run the test with a full trace:

```
./gradlew test --stacktrace --info


```

In the stacktrace, look for the first real DB complaint, usually something like:

“Failed to configure a DataSource: ‘url’ attribute is not specified…”

“Driver class name not found…”

“Communications link failure / Connection refused…”

“Access denied for user…”

result

```
    ***************************
    APPLICATION FAILED TO START
    ***************************

    Description:

    Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.

    Reason: Failed to determine a suitable driver class


    Action:

    Consider the following:
        If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.
        If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).
```

Install Postgres locally with Homebrew

Do this only if you intentionally want Postgres installed on macOS.

1) Install

 ```brew install postgresql@16```

2) Start the service

 ```brew services start postgresql@16```

3) Ensure psql is on your PATH

 ```brew link --force postgresql@16```


Verify:

```
psql --version
```

Fix (works whether Postgres is Docker or local)
1) Log in as a superuser

Try this first:

```
psql -U postgres -h localhost -p 5432
```

If that works, run these SQL commands:

```
CREATE ROLE billtracker WITH LOGIN PASSWORD 'billtracker';
CREATE DATABASE billtracker OWNER billtracker;
GRANT ALL PRIVILEGES ON DATABASE billtracker TO billtracker;
```

Then exit:
```
\q
```

Now retry:
```
psql "postgresql://billtracker:billtracker@localhost:5432/billtracker"
```

application.properties

```
spring.application.name=bill-tracker-ford-based-backend

datasource.url=jdbc:postgresql://localhost:5432/billtracker

```


# Missing db.changelog-master.yaml 

If Liquibase is on the classpath but db/changelog/db.changelog-master.yaml is missing, 
you’ll see a similar failure during test startup.

Add to application.properties for tests:
```
# Disable Liquibase during tests so startup doesn't require the missing changelog
spring.liquibase.enabled=false
spring.jpa.hibernate.ddl-auto=create-drop
```

## 0.1.5 Add a single “smoke endpoint” to prove request handling works

```backend/src/main/java/com/yourorg/financetracker/health/HealthController.java```


```java
package com.altruisticsoftwaredevelopment.bill_tracker_ford_based_backend.health;


import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HealthController {

  @GetMapping("/api/health")
  public String health() {
    return "ok";
  }
}

```

run

```
./gradlew bootRun

```

in another terminal or hit endpoint in hoppscotch

```
curl -i http://localhost:8080/api/health

```

```
test("status is 200", () => {
  expect(response.status).to.equal(200);
});

test("body equals 'ok'", () => {
  expect(response.body).to.equal("ok");
});


```

Hoppscotch test

Mapping (so this clicks mentally)
Postman	Hoppscotch
pm.test()	test()
pm.expect()	expect()
pm.response.to.have.status()	response.status
pm.response.text()	response.body

0.1.6 Add the first test (tiny TDD ritual)

```backend/src/test/java/com/yourorg/financetracker/health/HealthControllerTest.java```

```java
package com.altruisticsoftwaredevelopment.bill_tracker_ford_based_backend.health;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class HealthControllerTest {

  @LocalServerPort
  int port;

  @Test
  void healthEndpointReturnsOk() throws Exception {
    var url = new java.net.URL("http://localhost:" + port + "/api/health");
    var conn = (java.net.HttpURLConnection) url.openConnection();
    conn.setRequestMethod("GET");

    assertThat(conn.getResponseCode()).isEqualTo(200);

    try (var in = new java.io.BufferedReader(new java.io.InputStreamReader(conn.getInputStream()))) {
      var body = in.readLine();
      assertThat(body).isEqualTo("ok");
    }
  }
}

```

# we are not going to use local postgres moving forward and use docker compose postgres instead


